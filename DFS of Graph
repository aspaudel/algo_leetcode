//Standard Style
class Solution {
    // Function to return a list containing the DFS traversal of the graph.
    public ArrayList<Integer> dfsOfGraph(int V, ArrayList<ArrayList<Integer>> adj) {
        Stack<Integer> stack = new Stack<>();
        boolean[] isVisited = new boolean[V];
        ArrayList<Integer> arr = new ArrayList<>();
        arr.add(0);
        stack.add(0);
        isVisited[0] = true;
        boolean con;
        int node;
        while(!stack.isEmpty()) {
            node = stack.peek();
            con = true;
            for(int i = 0 ; i < adj.get(node).size() ; i++) {
                if(!isVisited[adj.get(node).get(i)]) {
                    con = false;
                    isVisited[adj.get(node).get(i)] = true;
                    arr.add(adj.get(node).get(i));
                    stack.add(adj.get(node).get(i));
                    break;
                }
            }
            if(con) {
                stack.pop();
            }
        }
        return arr;
    }
}

//Recursion Style
class Solution {
    ArrayList<Integer> res = new ArrayList<>();
    void DFS(int node, ArrayList<ArrayList<Integer>> adj, boolean[] isVisited) {
        isVisited[node] = true;
        res.add(node);
        for(int i : adj.get(node)) {
            if(!isVisited[i]) DFS(i, adj, isVisited);
        }
    }
    // Function to return a list containing the DFS traversal of the graph.
    public ArrayList<Integer> dfsOfGraph(int V, ArrayList<ArrayList<Integer>> adj) {
        boolean[] isVisited = new boolean[V];
        DFS(0, adj, isVisited);
        return res;
    }
}
